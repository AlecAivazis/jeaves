// Code generated by entc, DO NOT EDIT.

package db

import (
	"context"
	"errors"
	"fmt"

	"github.com/AlecAivazis/jeeves/db/bankitem"
	"github.com/AlecAivazis/jeeves/db/guild"
	"github.com/AlecAivazis/jeeves/db/guildbank"
	"github.com/AlecAivazis/jeeves/db/predicate"
	"github.com/facebookincubator/ent/dialect/sql"
)

// GuildBankUpdate is the builder for updating GuildBank entities.
type GuildBankUpdate struct {
	config
	channelID        *string
	displayMessageID *string
	balance          *int
	addbalance       *int
	items            map[int]struct{}
	guild            map[int]struct{}
	removedItems     map[int]struct{}
	clearedGuild     bool
	predicates       []predicate.GuildBank
}

// Where adds a new predicate for the builder.
func (gbu *GuildBankUpdate) Where(ps ...predicate.GuildBank) *GuildBankUpdate {
	gbu.predicates = append(gbu.predicates, ps...)
	return gbu
}

// SetChannelID sets the channelID field.
func (gbu *GuildBankUpdate) SetChannelID(s string) *GuildBankUpdate {
	gbu.channelID = &s
	return gbu
}

// SetDisplayMessageID sets the displayMessageID field.
func (gbu *GuildBankUpdate) SetDisplayMessageID(s string) *GuildBankUpdate {
	gbu.displayMessageID = &s
	return gbu
}

// SetBalance sets the balance field.
func (gbu *GuildBankUpdate) SetBalance(i int) *GuildBankUpdate {
	gbu.balance = &i
	gbu.addbalance = nil
	return gbu
}

// AddBalance adds i to balance.
func (gbu *GuildBankUpdate) AddBalance(i int) *GuildBankUpdate {
	if gbu.addbalance == nil {
		gbu.addbalance = &i
	} else {
		*gbu.addbalance += i
	}
	return gbu
}

// AddItemIDs adds the items edge to BankItem by ids.
func (gbu *GuildBankUpdate) AddItemIDs(ids ...int) *GuildBankUpdate {
	if gbu.items == nil {
		gbu.items = make(map[int]struct{})
	}
	for i := range ids {
		gbu.items[ids[i]] = struct{}{}
	}
	return gbu
}

// AddItems adds the items edges to BankItem.
func (gbu *GuildBankUpdate) AddItems(b ...*BankItem) *GuildBankUpdate {
	ids := make([]int, len(b))
	for i := range b {
		ids[i] = b[i].ID
	}
	return gbu.AddItemIDs(ids...)
}

// SetGuildID sets the guild edge to Guild by id.
func (gbu *GuildBankUpdate) SetGuildID(id int) *GuildBankUpdate {
	if gbu.guild == nil {
		gbu.guild = make(map[int]struct{})
	}
	gbu.guild[id] = struct{}{}
	return gbu
}

// SetNillableGuildID sets the guild edge to Guild by id if the given value is not nil.
func (gbu *GuildBankUpdate) SetNillableGuildID(id *int) *GuildBankUpdate {
	if id != nil {
		gbu = gbu.SetGuildID(*id)
	}
	return gbu
}

// SetGuild sets the guild edge to Guild.
func (gbu *GuildBankUpdate) SetGuild(g *Guild) *GuildBankUpdate {
	return gbu.SetGuildID(g.ID)
}

// RemoveItemIDs removes the items edge to BankItem by ids.
func (gbu *GuildBankUpdate) RemoveItemIDs(ids ...int) *GuildBankUpdate {
	if gbu.removedItems == nil {
		gbu.removedItems = make(map[int]struct{})
	}
	for i := range ids {
		gbu.removedItems[ids[i]] = struct{}{}
	}
	return gbu
}

// RemoveItems removes items edges to BankItem.
func (gbu *GuildBankUpdate) RemoveItems(b ...*BankItem) *GuildBankUpdate {
	ids := make([]int, len(b))
	for i := range b {
		ids[i] = b[i].ID
	}
	return gbu.RemoveItemIDs(ids...)
}

// ClearGuild clears the guild edge to Guild.
func (gbu *GuildBankUpdate) ClearGuild() *GuildBankUpdate {
	gbu.clearedGuild = true
	return gbu
}

// Save executes the query and returns the number of rows/vertices matched by this operation.
func (gbu *GuildBankUpdate) Save(ctx context.Context) (int, error) {
	if len(gbu.guild) > 1 {
		return 0, errors.New("db: multiple assignments on a unique edge \"guild\"")
	}
	return gbu.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (gbu *GuildBankUpdate) SaveX(ctx context.Context) int {
	affected, err := gbu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (gbu *GuildBankUpdate) Exec(ctx context.Context) error {
	_, err := gbu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (gbu *GuildBankUpdate) ExecX(ctx context.Context) {
	if err := gbu.Exec(ctx); err != nil {
		panic(err)
	}
}

func (gbu *GuildBankUpdate) sqlSave(ctx context.Context) (n int, err error) {
	var (
		builder  = sql.Dialect(gbu.driver.Dialect())
		selector = builder.Select(guildbank.FieldID).From(builder.Table(guildbank.Table))
	)
	for _, p := range gbu.predicates {
		p(selector)
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err = gbu.driver.Query(ctx, query, args, rows); err != nil {
		return 0, err
	}
	defer rows.Close()
	var ids []int
	for rows.Next() {
		var id int
		if err := rows.Scan(&id); err != nil {
			return 0, fmt.Errorf("db: failed reading id: %v", err)
		}
		ids = append(ids, id)
	}
	if len(ids) == 0 {
		return 0, nil
	}

	tx, err := gbu.driver.Tx(ctx)
	if err != nil {
		return 0, err
	}
	var (
		res     sql.Result
		updater = builder.Update(guildbank.Table).Where(sql.InInts(guildbank.FieldID, ids...))
	)
	if value := gbu.channelID; value != nil {
		updater.Set(guildbank.FieldChannelID, *value)
	}
	if value := gbu.displayMessageID; value != nil {
		updater.Set(guildbank.FieldDisplayMessageID, *value)
	}
	if value := gbu.balance; value != nil {
		updater.Set(guildbank.FieldBalance, *value)
	}
	if value := gbu.addbalance; value != nil {
		updater.Add(guildbank.FieldBalance, *value)
	}
	if !updater.Empty() {
		query, args := updater.Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return 0, rollback(tx, err)
		}
	}
	if len(gbu.removedItems) > 0 {
		eids := make([]int, len(gbu.removedItems))
		for eid := range gbu.removedItems {
			eids = append(eids, eid)
		}
		query, args := builder.Update(guildbank.ItemsTable).
			SetNull(guildbank.ItemsColumn).
			Where(sql.InInts(guildbank.ItemsColumn, ids...)).
			Where(sql.InInts(bankitem.FieldID, eids...)).
			Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return 0, rollback(tx, err)
		}
	}
	if len(gbu.items) > 0 {
		for _, id := range ids {
			p := sql.P()
			for eid := range gbu.items {
				p.Or().EQ(bankitem.FieldID, eid)
			}
			query, args := builder.Update(guildbank.ItemsTable).
				Set(guildbank.ItemsColumn, id).
				Where(sql.And(p, sql.IsNull(guildbank.ItemsColumn))).
				Query()
			if err := tx.Exec(ctx, query, args, &res); err != nil {
				return 0, rollback(tx, err)
			}
			affected, err := res.RowsAffected()
			if err != nil {
				return 0, rollback(tx, err)
			}
			if int(affected) < len(gbu.items) {
				return 0, rollback(tx, &ErrConstraintFailed{msg: fmt.Sprintf("one of \"items\" %v already connected to a different \"GuildBank\"", keys(gbu.items))})
			}
		}
	}
	if gbu.clearedGuild {
		query, args := builder.Update(guildbank.GuildTable).
			SetNull(guildbank.GuildColumn).
			Where(sql.InInts(guild.FieldID, ids...)).
			Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return 0, rollback(tx, err)
		}
	}
	if len(gbu.guild) > 0 {
		for _, id := range ids {
			eid := keys(gbu.guild)[0]
			query, args := builder.Update(guildbank.GuildTable).
				Set(guildbank.GuildColumn, eid).
				Where(sql.EQ(guildbank.FieldID, id).And().IsNull(guildbank.GuildColumn)).
				Query()
			if err := tx.Exec(ctx, query, args, &res); err != nil {
				return 0, rollback(tx, err)
			}
			affected, err := res.RowsAffected()
			if err != nil {
				return 0, rollback(tx, err)
			}
			if int(affected) < len(gbu.guild) {
				return 0, rollback(tx, &ErrConstraintFailed{msg: fmt.Sprintf("one of \"guild\" %v already connected to a different \"GuildBank\"", keys(gbu.guild))})
			}
		}
	}
	if err = tx.Commit(); err != nil {
		return 0, err
	}
	return len(ids), nil
}

// GuildBankUpdateOne is the builder for updating a single GuildBank entity.
type GuildBankUpdateOne struct {
	config
	id               int
	channelID        *string
	displayMessageID *string
	balance          *int
	addbalance       *int
	items            map[int]struct{}
	guild            map[int]struct{}
	removedItems     map[int]struct{}
	clearedGuild     bool
}

// SetChannelID sets the channelID field.
func (gbuo *GuildBankUpdateOne) SetChannelID(s string) *GuildBankUpdateOne {
	gbuo.channelID = &s
	return gbuo
}

// SetDisplayMessageID sets the displayMessageID field.
func (gbuo *GuildBankUpdateOne) SetDisplayMessageID(s string) *GuildBankUpdateOne {
	gbuo.displayMessageID = &s
	return gbuo
}

// SetBalance sets the balance field.
func (gbuo *GuildBankUpdateOne) SetBalance(i int) *GuildBankUpdateOne {
	gbuo.balance = &i
	gbuo.addbalance = nil
	return gbuo
}

// AddBalance adds i to balance.
func (gbuo *GuildBankUpdateOne) AddBalance(i int) *GuildBankUpdateOne {
	if gbuo.addbalance == nil {
		gbuo.addbalance = &i
	} else {
		*gbuo.addbalance += i
	}
	return gbuo
}

// AddItemIDs adds the items edge to BankItem by ids.
func (gbuo *GuildBankUpdateOne) AddItemIDs(ids ...int) *GuildBankUpdateOne {
	if gbuo.items == nil {
		gbuo.items = make(map[int]struct{})
	}
	for i := range ids {
		gbuo.items[ids[i]] = struct{}{}
	}
	return gbuo
}

// AddItems adds the items edges to BankItem.
func (gbuo *GuildBankUpdateOne) AddItems(b ...*BankItem) *GuildBankUpdateOne {
	ids := make([]int, len(b))
	for i := range b {
		ids[i] = b[i].ID
	}
	return gbuo.AddItemIDs(ids...)
}

// SetGuildID sets the guild edge to Guild by id.
func (gbuo *GuildBankUpdateOne) SetGuildID(id int) *GuildBankUpdateOne {
	if gbuo.guild == nil {
		gbuo.guild = make(map[int]struct{})
	}
	gbuo.guild[id] = struct{}{}
	return gbuo
}

// SetNillableGuildID sets the guild edge to Guild by id if the given value is not nil.
func (gbuo *GuildBankUpdateOne) SetNillableGuildID(id *int) *GuildBankUpdateOne {
	if id != nil {
		gbuo = gbuo.SetGuildID(*id)
	}
	return gbuo
}

// SetGuild sets the guild edge to Guild.
func (gbuo *GuildBankUpdateOne) SetGuild(g *Guild) *GuildBankUpdateOne {
	return gbuo.SetGuildID(g.ID)
}

// RemoveItemIDs removes the items edge to BankItem by ids.
func (gbuo *GuildBankUpdateOne) RemoveItemIDs(ids ...int) *GuildBankUpdateOne {
	if gbuo.removedItems == nil {
		gbuo.removedItems = make(map[int]struct{})
	}
	for i := range ids {
		gbuo.removedItems[ids[i]] = struct{}{}
	}
	return gbuo
}

// RemoveItems removes items edges to BankItem.
func (gbuo *GuildBankUpdateOne) RemoveItems(b ...*BankItem) *GuildBankUpdateOne {
	ids := make([]int, len(b))
	for i := range b {
		ids[i] = b[i].ID
	}
	return gbuo.RemoveItemIDs(ids...)
}

// ClearGuild clears the guild edge to Guild.
func (gbuo *GuildBankUpdateOne) ClearGuild() *GuildBankUpdateOne {
	gbuo.clearedGuild = true
	return gbuo
}

// Save executes the query and returns the updated entity.
func (gbuo *GuildBankUpdateOne) Save(ctx context.Context) (*GuildBank, error) {
	if len(gbuo.guild) > 1 {
		return nil, errors.New("db: multiple assignments on a unique edge \"guild\"")
	}
	return gbuo.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (gbuo *GuildBankUpdateOne) SaveX(ctx context.Context) *GuildBank {
	gb, err := gbuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return gb
}

// Exec executes the query on the entity.
func (gbuo *GuildBankUpdateOne) Exec(ctx context.Context) error {
	_, err := gbuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (gbuo *GuildBankUpdateOne) ExecX(ctx context.Context) {
	if err := gbuo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (gbuo *GuildBankUpdateOne) sqlSave(ctx context.Context) (gb *GuildBank, err error) {
	var (
		builder  = sql.Dialect(gbuo.driver.Dialect())
		selector = builder.Select(guildbank.Columns...).From(builder.Table(guildbank.Table))
	)
	guildbank.ID(gbuo.id)(selector)
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err = gbuo.driver.Query(ctx, query, args, rows); err != nil {
		return nil, err
	}
	defer rows.Close()
	var ids []int
	for rows.Next() {
		var id int
		gb = &GuildBank{config: gbuo.config}
		if err := gb.FromRows(rows); err != nil {
			return nil, fmt.Errorf("db: failed scanning row into GuildBank: %v", err)
		}
		id = gb.ID
		ids = append(ids, id)
	}
	switch n := len(ids); {
	case n == 0:
		return nil, &ErrNotFound{fmt.Sprintf("GuildBank with id: %v", gbuo.id)}
	case n > 1:
		return nil, fmt.Errorf("db: more than one GuildBank with the same id: %v", gbuo.id)
	}

	tx, err := gbuo.driver.Tx(ctx)
	if err != nil {
		return nil, err
	}
	var (
		res     sql.Result
		updater = builder.Update(guildbank.Table).Where(sql.InInts(guildbank.FieldID, ids...))
	)
	if value := gbuo.channelID; value != nil {
		updater.Set(guildbank.FieldChannelID, *value)
		gb.ChannelID = *value
	}
	if value := gbuo.displayMessageID; value != nil {
		updater.Set(guildbank.FieldDisplayMessageID, *value)
		gb.DisplayMessageID = *value
	}
	if value := gbuo.balance; value != nil {
		updater.Set(guildbank.FieldBalance, *value)
		gb.Balance = *value
	}
	if value := gbuo.addbalance; value != nil {
		updater.Add(guildbank.FieldBalance, *value)
		gb.Balance += *value
	}
	if !updater.Empty() {
		query, args := updater.Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return nil, rollback(tx, err)
		}
	}
	if len(gbuo.removedItems) > 0 {
		eids := make([]int, len(gbuo.removedItems))
		for eid := range gbuo.removedItems {
			eids = append(eids, eid)
		}
		query, args := builder.Update(guildbank.ItemsTable).
			SetNull(guildbank.ItemsColumn).
			Where(sql.InInts(guildbank.ItemsColumn, ids...)).
			Where(sql.InInts(bankitem.FieldID, eids...)).
			Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return nil, rollback(tx, err)
		}
	}
	if len(gbuo.items) > 0 {
		for _, id := range ids {
			p := sql.P()
			for eid := range gbuo.items {
				p.Or().EQ(bankitem.FieldID, eid)
			}
			query, args := builder.Update(guildbank.ItemsTable).
				Set(guildbank.ItemsColumn, id).
				Where(sql.And(p, sql.IsNull(guildbank.ItemsColumn))).
				Query()
			if err := tx.Exec(ctx, query, args, &res); err != nil {
				return nil, rollback(tx, err)
			}
			affected, err := res.RowsAffected()
			if err != nil {
				return nil, rollback(tx, err)
			}
			if int(affected) < len(gbuo.items) {
				return nil, rollback(tx, &ErrConstraintFailed{msg: fmt.Sprintf("one of \"items\" %v already connected to a different \"GuildBank\"", keys(gbuo.items))})
			}
		}
	}
	if gbuo.clearedGuild {
		query, args := builder.Update(guildbank.GuildTable).
			SetNull(guildbank.GuildColumn).
			Where(sql.InInts(guild.FieldID, ids...)).
			Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return nil, rollback(tx, err)
		}
	}
	if len(gbuo.guild) > 0 {
		for _, id := range ids {
			eid := keys(gbuo.guild)[0]
			query, args := builder.Update(guildbank.GuildTable).
				Set(guildbank.GuildColumn, eid).
				Where(sql.EQ(guildbank.FieldID, id).And().IsNull(guildbank.GuildColumn)).
				Query()
			if err := tx.Exec(ctx, query, args, &res); err != nil {
				return nil, rollback(tx, err)
			}
			affected, err := res.RowsAffected()
			if err != nil {
				return nil, rollback(tx, err)
			}
			if int(affected) < len(gbuo.guild) {
				return nil, rollback(tx, &ErrConstraintFailed{msg: fmt.Sprintf("one of \"guild\" %v already connected to a different \"GuildBank\"", keys(gbuo.guild))})
			}
		}
	}
	if err = tx.Commit(); err != nil {
		return nil, err
	}
	return gb, nil
}
